## CORE BACKEND "POST"

Post

```java
package com.example.microblog.domain;

import jakarta.persistence.*;
import java.time.Instant;
import java.util.Objects;

@Entity
@Table(
  name = "post",
  indexes = {
    @Index(name = "idx_post_author_created", columnList = "author_id, created_at"),
    @Index(name = "idx_post_created", columnList = "created_at"),
  }
)
public class Post {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @ManyToOne(optional = false)
  @JoinColumn(name = "author_id")
  private User author; // jhi_user generated by JHipster

  @Column(length = 10000, nullable = false)
  private String content;

  @Column(name = "created_at", nullable = false)
  private Instant createdAt = Instant.now();

  @Column(name = "updated_at")
  private Instant updatedAt;

  @Column(name = "like_count", nullable = false)
  private Integer likeCount = 0;

  @Column(name = "comment_count", nullable = false)
  private Integer commentCount = 0;

  @Column(name = "visibility", nullable = false)
  private String visibility = "PUBLIC";
  // getters/setters, equals/hashCode
  // (Omitted here for brevity — generate with IDE)
}

```

PostRepository

```java
package com.example.microblog.repository;

import com.example.microblog.domain.Post;
import java.util.Collection;
import java.util.List;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface PostRepository extends JpaRepository<Post, Long> {
  @Query("SELECT p FROM Post p WHERE p.author.id IN :authorIds ORDER BY p.createdAt DESC")
  Page<Post> findByAuthorIds(List<Long> authorIds, Pageable pageable);

  // fetch posts by ids (we'll order result in-memory to match Redis ordering)
  List<Post> findByIdIn(Collection<Long> ids);
}

```

FollowRepository

```java
package com.example.microblog.repository;

import com.example.microblog.domain.Follow;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface FollowRepository extends JpaRepository<Follow, Long> {
  // get followee IDs for given follower
  @Query("SELECT f.followee.id FROM Follow f WHERE f.follower.id = :followerId")
  List<Long> findFolloweeIdsByFollowerId(Long followerId);

  // stream follower IDs for a given author (used by push worker)
  @Query("SELECT f.follower.id FROM Follow f WHERE f.followee.id = :followeeId")
  List<Long> findFollowerIdsByFolloweeId(Long followeeId);
}

```

PostCreatedEvent

```java
package com.example.microblog.events;

import java.time.Instant;

public class PostCreatedEvent {

  private final Long postId;
  private final Long authorId;
  private final Instant createdAt;

  public PostCreatedEvent(Long postId, Long authorId, Instant createdAt) {
    this.postId = postId;
    this.authorId = authorId;
    this.createdAt = createdAt;
  }

  public Long getPostId() {
    return postId;
  }

  public Long getAuthorId() {
    return authorId;
  }

  public Instant getCreatedAt() {
    return createdAt;
  }
}

```

PostService

```java
@Service
public class PostService {

  private final PostRepository postRepository;
  private final ApplicationEventPublisher eventPublisher;

  // optionally inject ES repo to index sync

  public PostService(PostRepository postRepository, ApplicationEventPublisher eventPublisher) {
    this.postRepository = postRepository;
    this.eventPublisher = eventPublisher;
  }

  @Transactional
  public Post createPost(Post post) {
    post.setCreatedAt(Instant.now());
    Post saved = postRepository.save(post);
    // publish event for feed fan-out and ES indexing
    eventPublisher.publishEvent(new PostCreatedEvent(saved.getId(), saved.getAuthor().getId(), saved.getCreatedAt()));
    // (optionally) index to ES here or from async listener
    return saved;
  }
}

```

RedisFeedService (timeline read + DB fallback)
This is central: tries Redis first for feed:{userId}, else falls back to DB query.

```java
import com.example.microblog.domain.Post;
import com.example.microblog.repository.FollowRepository;
import com.example.microblog.repository.PostRepository;
import java.util.*;
import java.util.stream.Collectors;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

@Service
public class RedisFeedService {

  private final RedisTemplate<String, String> redisTemplate;
  private final PostRepository postRepository;
  private final FollowRepository followRepository;

  public RedisFeedService(RedisTemplate<String, String> redisTemplate, PostRepository postRepository, FollowRepository followRepository) {
    this.redisTemplate = redisTemplate;
    this.postRepository = postRepository;
    this.followRepository = followRepository;
  }

  public Page<Post> getTimeline(Long userId, Pageable pageable) {
    String feedKey = "feed:" + userId;
    // try redis
    Set<String> idSet = redisTemplate
      .opsForZSet()
      .reverseRange(feedKey, pageable.getOffset(), pageable.getOffset() + pageable.getPageSize() - 1);

    if (idSet != null && !idSet.isEmpty()) {
      List<Long> ids = idSet.stream().map(Long::valueOf).collect(Collectors.toList());
      List<Post> posts = postRepository.findByIdIn(ids);
      // need to order posts according to ids order (which came newest->oldest)
      Map<Long, Post> map = posts.stream().collect(Collectors.toMap(Post::getId, p -> p));
      List<Post> ordered = ids.stream().map(map::get).filter(Objects::nonNull).collect(Collectors.toList());
      return new PageImpl<>(ordered, pageable, ordered.size());
    }

    // fallback: fan-out on read: get followee ids and query DB
    List<Long> followeeIds = followRepository.findFolloweeIdsByFollowerId(userId);
    // include own posts
    followeeIds.add(userId);
    Page<Post> page = postRepository.findByAuthorIds(followeeIds, pageable);
    return page;
  }
}

```

RedisPushWorker — async fan-out on write

```java
package com.example.microblog.worker;

import com.example.microblog.events.PostCreatedEvent;
import com.example.microblog.repository.FollowRepository;
import java.util.List;
import org.springframework.context.event.EventListener;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

@Component
public class RedisPushWorker {

  private final FollowRepository followRepository;
  private final RedisTemplate<String, String> redisTemplate;
  private static final int BATCH = 1000;

  public RedisPushWorker(FollowRepository followRepository, RedisTemplate<String, String> redisTemplate) {
    this.followRepository = followRepository;
    this.redisTemplate = redisTemplate;
  }

  @Async // configure @EnableAsync in main config
  @EventListener
  public void handlePostCreated(PostCreatedEvent event) {
    Long authorId = event.getAuthorId();
    Long postId = event.getPostId();
    // fetch follower ids — NOTE: replace with paged/streamed approach for huge follower sets
    List<Long> followerIds = followRepository.findFollowerIdsByFolloweeId(authorId);
    // in production: page through followers in batches to avoid OOM and use a queue if > threshold
    for (Long followerId : followerIds) {
      String key = "feed:" + followerId;
      // use opsForZSet add directly — pipeline would be better for large batches
      redisTemplate.opsForZSet().add(key, String.valueOf(postId), event.getCreatedAt().toEpochMilli());
      // optionally trim feed size
      redisTemplate.opsForZSet().removeRange(key, 1000, -1);
    }
  }
}

```

PostResource (Controller) — minimal endpoints

```java
package com.example.microblog.web.rest;

import com.example.microblog.domain.Post;
import com.example.microblog.repository.UserRepository;
import com.example.microblog.service.PostService;
import com.example.microblog.service.RedisFeedService;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class PostResource {

  private final PostService postService;
  private final RedisFeedService timelineService;
  private final UserRepository userRepository;

  public PostResource(PostService postService, RedisFeedService timelineService, UserRepository userRepository) {
    this.postService = postService;
    this.timelineService = timelineService;
    this.userRepository = userRepository;
  }

  @PostMapping("/posts")
  public ResponseEntity<Post> createPost(@RequestBody Post post, Authentication auth) {
    // resolve user from auth
    String login = auth.getName();
    userRepository.findOneByLogin(login).ifPresent(post::setAuthor);
    Post saved = postService.createPost(post);
    return ResponseEntity.status(201).body(saved);
  }

  @GetMapping("/timeline")
  public ResponseEntity<Page<Post>> getTimeline(Pageable pageable, Authentication auth) {
    Long userId = userRepository.findOneByLogin(auth.getName()).map(u -> u.getId()).orElseThrow();
    Page<Post> page = timelineService.getTimeline(userId, pageable);
    return ResponseEntity.ok(page);
  }
}

```

Unit test (TimelineService/RedisFeedService) — Mockito

```java
package com.example.microblog.service;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import com.example.microblog.domain.Post;
import com.example.microblog.repository.FollowRepository;
import com.example.microblog.repository.PostRepository;
import java.time.Instant;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.redis.core.RedisTemplate;

class RedisFeedServiceTest {

  @Mock
  RedisTemplate<String, String> redisTemplate;

  @Mock
  PostRepository postRepository;

  @Mock
  FollowRepository followRepository;

  @InjectMocks
  RedisFeedService feedService;

  public RedisFeedServiceTest() {
    MockitoAnnotations.openMocks(this);
  }

  @Test
  void fallbackToDbWhenRedisEmpty() {
    Long userId = 1L;
    PageRequest pageable = PageRequest.of(0, 20);

    // simulate redis returning empty
    when(redisTemplate.opsForZSet().reverseRange("feed:" + userId, 0L, 19L)).thenReturn(Collections.emptySet());
    // followees
    when(followRepository.findFolloweeIdsByFollowerId(userId)).thenReturn(List.of(2L));
    // posts from DB
    Post p = new Post();
    p.setId(100L);
    p.setContent("hello");
    p.setCreatedAt(Instant.now());
    Page<Post> page = Page.of(List.of(p), pageable, 1);
    when(postRepository.findByAuthorIds(anyList(), eq(pageable))).thenReturn(page);

    Page<Post> result = feedService.getTimeline(userId, pageable);
    assertEquals(1, result.getTotalElements());
    assertEquals("hello", result.getContent().get(0).getContent());
  }
  // More tests: redis hit ordering, etc.
}

```

Minimal configuration additions
Enable async: add @EnableAsync in your Spring Boot application class:

```java
@SpringBootApplication
@EnableAsync
public class MicroblogApp { ... }

```

Configure RedisTemplate bean (JHipster may already have one):

```java
@Bean
public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory cf) {
  RedisTemplate<String, String> rt = new RedisTemplate<>();
  rt.setConnectionFactory(cf);
  rt.setKeySerializer(new StringRedisSerializer());
  rt.setValueSerializer(new StringRedisSerializer());
  return rt;
}

```

## Liquibase changelogs

1. 00000000000000_initial_schema.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:pro="http://www.liquibase.org/xml/ns/pro"
    xsi:schemaLocation="
        http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd
        http://www.liquibase.org/xml/ns/pro
        http://www.liquibase.org/xml/ns/pro/liquibase-pro-3.8.xsd">

    <changeSet id="20250907-01-create-post" author="assistant">
        <createTable tableName="post">
            <column name="id" type="bigint" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="pk_post"/>
            </column>
            <column name="author_id" type="bigint">
                <constraints nullable="false"/>
            </column>
            <column name="content" type="text">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="timestamptz">
                <constraints nullable="false"/>
                <defaultValueComputed>now()</defaultValueComputed>
            </column>
            <column name="updated_at" type="timestamptz"/>
            <column name="like_count" type="integer" defaultValueNumeric="0">
                <constraints nullable="false"/>
            </column>
            <column name="comment_count" type="integer" defaultValueNumeric="0">
                <constraints nullable="false"/>
            </column>
            <column name="visibility" type="varchar(20)" defaultValue="PUBLIC">
                <constraints nullable="false"/>
            </column>
        </createTable>

        <addForeignKeyConstraint baseTableName="post"
                                 baseColumnNames="author_id"
                                 referencedTableName="jhi_user"
                                 referencedColumnNames="id"
                                 constraintName="fk_post_author"/>

        <createIndex tableName="post" indexName="idx_post_author_created">
            <column name="author_id"/>
            <column name="created_at"/>
        </createIndex>

        <createIndex tableName="post" indexName="idx_post_created">
            <column name="created_at"/>
        </createIndex>

        <createIndex tableName="post" indexName="idx_post_content_gin" unique="false" tablespace="">
            <customChange class="liquibase.ext.usertype.CustomIndexChange" />
            <!-- Note: If your Liquibase setup doesn't support creating GIN via standard tags,
                 run raw SQL below (see sql block) -->
        </changeSet>

    <changeSet id="20250907-02-create-follow" author="assistant">
        <createTable tableName="follow">
            <column name="id" type="bigint" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="pk_follow"/>
            </column>
            <column name="follower_id" type="bigint">
                <constraints nullable="false"/>
            </column>
            <column name="followee_id" type="bigint">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="timestamptz">
                <defaultValueComputed>now()</defaultValueComputed>
            </column>
        </createTable>

        <addForeignKeyConstraint baseTableName="follow" baseColumnNames="follower_id"
                                 referencedTableName="jhi_user" referencedColumnNames="id"
                                 constraintName="fk_follow_follower"/>

        <addForeignKeyConstraint baseTableName="follow" baseColumnNames="followee_id"
                                 referencedTableName="jhi_user" referencedColumnNames="id"
                                 constraintName="fk_follow_followee"/>

        <addUniqueConstraint tableName="follow" columnNames="follower_id,followee_id" constraintName="uk_follow_unique"/>
        <createIndex tableName="follow" indexName="idx_follow_follower"><column name="follower_id"/></createIndex>
        <createIndex tableName="follow" indexName="idx_follow_followee"><column name="followee_id"/></createIndex>
    </changeSet>

    <changeSet id="20250907-03-create-post_like" author="assistant">
        <createTable tableName="post_like">
            <column name="id" type="bigint" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="pk_post_like"/>
            </column>
            <column name="post_id" type="bigint"><constraints nullable="false"/></column>
            <column name="user_id" type="bigint"><constraints nullable="false"/></column>
            <column name="created_at" type="timestamptz"><defaultValueComputed>now()</defaultValueComputed></column>
        </createTable>
        <addForeignKeyConstraint baseTableName="post_like" baseColumnNames="post_id"
                                 referencedTableName="post" referencedColumnNames="id"
                                 constraintName="fk_postlike_post"/>
        <addForeignKeyConstraint baseTableName="post_like" baseColumnNames="user_id"
                                 referencedTableName="jhi_user" referencedColumnNames="id"
                                 constraintName="fk_postlike_user"/>
        <addUniqueConstraint tableName="post_like" columnNames="post_id,user_id" constraintName="uk_postlike_unique"/>
        <createIndex tableName="post_like" indexName="idx_like_post"><column name="post_id"/></createIndex>
        <createIndex tableName="post_like" indexName="idx_like_user"><column name="user_id"/></createIndex>
    </changeSet>

    <changeSet id="20250907-04-create-comment" author="assistant">
        <createTable tableName="comment">
            <column name="id" type="bigint" autoIncrement="true">
                <constraints primaryKey="true" primaryKeyName="pk_comment"/>
            </column>
            <column name="post_id" type="bigint"><constraints nullable="false"/></column>
            <column name="author_id" type="bigint"><constraints nullable="false"/></column>
            <column name="content" type="text"><constraints nullable="false"/></column>
            <column name="created_at" type="timestamptz"><defaultValueComputed>now()</defaultValueComputed></column>
        </createTable>

        <addForeignKeyConstraint baseTableName="comment" baseColumnNames="post_id"
                                 referencedTableName="post" referencedColumnNames="id" constraintName="fk_comment_post"/>
        <addForeignKeyConstraint baseTableName="comment" baseColumnNames="author_id"
                                 referencedTableName="jhi_user" referencedColumnNames="id" constraintName="fk_comment_author"/>
        <createIndex tableName="comment" indexName="idx_comment_post">
            <column name="post_id"/>
            <column name="created_at"/>
        </createIndex>
    </changeSet>

    <!-- Raw SQL change for GIN text index (Postgres) -->
    <changeSet id="20250907-05-create-post-gin" author="assistant">
        <comment>Create GIN index on post content for full text search fallback</comment>
        <sql>
            CREATE INDEX IF NOT EXISTS idx_post_content_gin ON post USING gin (to_tsvector('english', content));
        </sql>
    </changeSet>

</databaseChangeLog>

```

## DTOs + MapStruct mappers

PostDTO.java

```java
package com.example.microblog.service.dto;

import java.io.Serializable;
import java.time.Instant;

public class PostDTO implements Serializable {

  private Long id;
  private Long authorId;
  private String authorLogin;
  private String content;
  private Instant createdAt;
  private Instant updatedAt;
  private Integer likeCount;
  private Integer commentCount;
  private String visibility;
  // getters and setters
  // equals/hashCode/toString (omitted for brevity)
}

```

PostMapper.java

```java
package com.example.microblog.service.mapper;

import com.example.microblog.domain.Post;
import com.example.microblog.domain.User;
import com.example.microblog.service.dto.PostDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring", uses = {})
public interface PostMapper {
  @Mapping(source = "author.id", target = "authorId")
  @Mapping(source = "author.login", target = "authorLogin")
  PostDTO toDto(Post post);

  @Mapping(source = "authorId", target = "author")
  Post toEntity(PostDTO dto);

  default User map(Long userId) {
    if (userId == null) return null;
    User u = new User();
    u.setId(userId);
    return u;
  }
}

```

CommentMapper

```java
package com.example.microblog.service.mapper;

import com.example.microblog.domain.Comment;
import com.example.microblog.service.dto.CommentDTO;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface CommentMapper {
  @Mapping(source = "author.id", target = "authorId")
  @Mapping(source = "author.login", target = "authorLogin")
  CommentDTO toDto(Comment comment);

  @Mapping(source = "authorId", target = "author")
  @Mapping(source = "postId", target = "post")
  Comment toEntity(CommentDTO dto);

  default com.example.microblog.domain.User mapUser(Long id) {
    if (id == null) return null;
    com.example.microblog.domain.User u = new com.example.microblog.domain.User();
    u.setId(id);
    return u;
  }

  default com.example.microblog.domain.Post mapPost(Long id) {
    if (id == null) return null;
    com.example.microblog.domain.Post p = new com.example.microblog.domain.Post();
    p.setId(id);
    return p;
  }
}

```

Controllers for likes/comments/follow

```java
import com.example.microblog.domain.Post;
import com.example.microblog.domain.PostLike;
import com.example.microblog.repository.PostLikeRepository;
import com.example.microblog.repository.PostRepository;
import com.example.microblog.repository.UserRepository;
import java.time.Instant;
import java.util.Optional;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class LikeResource {

  private final PostRepository postRepository;
  private final PostLikeRepository likeRepository;
  private final UserRepository userRepository;

  public LikeResource(PostRepository postRepository, PostLikeRepository likeRepository, UserRepository userRepository) {
    this.postRepository = postRepository;
    this.likeRepository = likeRepository;
    this.userRepository = userRepository;
  }

  @PostMapping("/posts/{id}/like")
  @Transactional
  public ResponseEntity<?> likePost(@PathVariable Long id, Authentication auth) {
    String login = auth.getName();
    Optional<com.example.microblog.domain.User> userOpt = userRepository.findOneByLogin(login);
    if (userOpt.isEmpty()) return ResponseEntity.status(401).build();
    var user = userOpt.get();

    if (likeRepository.existsByPostIdAndUserId(id, user.getId())) {
      // idempotent
      Post post = postRepository.findById(id).orElseThrow();
      return ResponseEntity.ok().body(new LikeResponse(true, post.getLikeCount()));
    }

    PostLike like = new PostLike();
    like.setPost(postRepository.getOne(id));
    like.setUser(user);
    like.setCreatedAt(Instant.now());
    likeRepository.save(like);

    // increment counter
    postRepository.incrementLikeCountById(id);

    Post post = postRepository.findById(id).orElseThrow();
    return ResponseEntity.ok().body(new LikeResponse(true, post.getLikeCount()));
  }

  @DeleteMapping("/posts/{id}/like")
  @Transactional
  public ResponseEntity<?> unlikePost(@PathVariable Long id, Authentication auth) {
    String login = auth.getName();
    var user = userRepository.findOneByLogin(login).orElseThrow();
    likeRepository.deleteByPostIdAndUserId(id, user.getId());
    postRepository.decrementLikeCountById(id);
    Post post = postRepository.findById(id).orElseThrow();
    return ResponseEntity.ok(new LikeResponse(false, post.getLikeCount()));
  }

  static class LikeResponse {

    public boolean liked;
    public int likeCount;

    public LikeResponse(boolean liked, int likeCount) {
      this.liked = liked;
      this.likeCount = likeCount;
    }
  }
}

```

CommentResource.java

```java
package com.example.microblog.web.rest;

import com.example.microblog.domain.Comment;
import com.example.microblog.domain.Post;
import com.example.microblog.repository.CommentRepository;
import com.example.microblog.repository.PostRepository;
import com.example.microblog.repository.UserRepository;
import java.time.Instant;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class CommentResource {

  private final CommentRepository commentRepository;
  private final PostRepository postRepository;
  private final UserRepository userRepository;

  public CommentResource(CommentRepository commentRepository, PostRepository postRepository, UserRepository userRepository) {
    this.commentRepository = commentRepository;
    this.postRepository = postRepository;
    this.userRepository = userRepository;
  }

  @PostMapping("/posts/{id}/comment")
  @Transactional
  public ResponseEntity<?> commentOnPost(@PathVariable Long id, @RequestBody CommentRequest request, Authentication auth) {
    var user = userRepository.findOneByLogin(auth.getName()).orElseThrow();
    Post post = postRepository.findById(id).orElseThrow();

    Comment c = new Comment();
    c.setPost(post);
    c.setAuthor(user);
    c.setContent(request.content);
    c.setCreatedAt(Instant.now());
    Comment saved = commentRepository.save(c);

    postRepository.incrementCommentCountById(id);

    return ResponseEntity.status(201).body(saved);
  }

  static class CommentRequest {

    public String content;
  }
}

```

FollowResource

```java
package com.example.microblog.web.rest;

import com.example.microblog.domain.Follow;
import com.example.microblog.domain.User;
import com.example.microblog.repository.FollowRepository;
import com.example.microblog.repository.UserRepository;
import java.time.Instant;
import java.util.Optional;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class FollowResource {

  private final FollowRepository followRepository;
  private final UserRepository userRepository;

  public FollowResource(FollowRepository followRepository, UserRepository userRepository) {
    this.followRepository = followRepository;
    this.userRepository = userRepository;
  }

  @PostMapping("/users/{id}/follow")
  @Transactional
  public ResponseEntity<?> follow(@PathVariable Long id, Authentication auth) {
    User follower = userRepository.findOneByLogin(auth.getName()).orElseThrow();
    if (follower.getId().equals(id)) return ResponseEntity.badRequest().body("cannot follow self");

    User followee = userRepository.findById(id).orElseThrow();

    boolean exists = followRepository.existsByFollowerIdAndFolloweeId(follower.getId(), followee.getId());
    if (exists) {
      // already follows -> unfollow
      followRepository.deleteByFollowerIdAndFolloweeId(follower.getId(), followee.getId());
      return ResponseEntity.ok(new FollowResponse(false));
    } else {
      Follow f = new Follow();
      f.setFollower(follower);
      f.setFollowee(followee);
      f.setCreatedAt(Instant.now());
      followRepository.save(f);
      return ResponseEntity.ok(new FollowResponse(true));
    }
  }

  static class FollowResponse {

    public boolean followed;

    public FollowResponse(boolean followed) {
      this.followed = followed;
    }
  }
}

```

## Production-ready RedisPushWorker (paged + pipelined + retry)

```java
package com.example.microblog.worker;

import com.example.microblog.events.PostCreatedEvent;
import com.example.microblog.repository.FollowRepository;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.TimeUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.connection.RedisZSetCommands;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

/**
 * Production-ready: batch follower fetch, pipeline ZADD writes, simple retry/backoff on failures.
 * Note: for huge follower sets prefer streaming from DB with cursor or using Kafka to buffer fan-out jobs.
 */
@Component
public class PipelinedRedisPushWorker {

  private final Logger log = LoggerFactory.getLogger(PipelinedRedisPushWorker.class);
  private final FollowRepository followRepository;
  private final RedisTemplate<String, String> redisTemplate;

  // tuning params
  private static final int PAGE_SIZE = 2000;
  private static final int MAX_RETRIES = 3;
  private static final long RETRY_BACKOFF_MS = 1000L; // exponential backoff base

  public PipelinedRedisPushWorker(FollowRepository followRepository, RedisTemplate<String, String> redisTemplate) {
    this.followRepository = followRepository;
    this.redisTemplate = redisTemplate;
  }

  @Async("taskExecutor")
  @EventListener
  public void onPostCreated(PostCreatedEvent e) {
    Long authorId = e.getAuthorId();
    Long postId = e.getPostId();
    long score = e.getCreatedAt().toEpochMilli();

    int page = 0;
    List<Long> followers;
    do {
      followers = followRepository.findFollowerIdsByFolloweeIdPaged(authorId, page * PAGE_SIZE, PAGE_SIZE);
      if (followers == null || followers.isEmpty()) break;
      // chunk followers into smaller batches for pipeline to avoid huge command payloads
      int chunkSize = 500;
      for (int i = 0; i < followers.size(); i += chunkSize) {
        List<Long> chunk = followers.subList(i, Math.min(i + chunkSize, followers.size()));
        pushToRedisWithRetry(chunk, postId, score);
      }
      page++;
    } while (followers.size() == PAGE_SIZE);
  }

  private void pushToRedisWithRetry(List<Long> followerIds, Long postId, long score) {
    int attempt = 0;
    boolean ok = false;
    while (attempt < MAX_RETRIES && !ok) {
      try {
        pipelineZaddAndTrim(followerIds, postId, score);
        ok = true;
      } catch (Exception ex) {
        attempt++;
        log.warn("Failed to push feed batch attempt {}/{}: {}", attempt, MAX_RETRIES, ex.getMessage());
        if (attempt < MAX_RETRIES) {
          try {
            Thread.sleep(RETRY_BACKOFF_MS * attempt);
          } catch (InterruptedException ignore) {}
        } else {
          log.error("Dropping push batch after {} attempts, followerCount={}", MAX_RETRIES, followerIds.size());
          // Optionally: write to dead-letter queue for later processing
        }
      }
    }
  }

  private void pipelineZaddAndTrim(List<Long> followerIds, Long postId, long score) {
    redisTemplate.executePipelined(
      (RedisCallback<Object>) connection -> {
        byte[] member = String.valueOf(postId).getBytes(StandardCharsets.UTF_8);
        for (Long fid : followerIds) {
          byte[] key = ("feed:" + fid).getBytes(StandardCharsets.UTF_8);
          // ZADD
          connection.zAdd(key, score, member, RedisZSetCommands.Range.BYLEX);
          // ZREMRANGEBYRANK to keep only top N (trim older entries)
          // remove items from rank 1000..end (keep 0..999)
          connection.zRemRangeByRank(key, 1000, -1);
        }
        return null;
      }
    );
  }
}

```

## Elasticsearch integration (index + search)

Files under src/main/java/com/example/microblog/search/
PostSearchService.java

```java
package com.example.microblog.search;

import com.example.microblog.domain.Post;
import java.util.List;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.elasticsearch.client.elc.*;
import org.springframework.data.elasticsearch.core.*;
import org.springframework.stereotype.Service;

@Service
public class PostSearchService {

  private final Logger log = LoggerFactory.getLogger(PostSearchService.class);
  private final ElasticsearchOperations es;

  public PostSearchService(ElasticsearchOperations es) {
    this.es = es;
  }

  public void index(Post p) {
    try {
      es.index(IndexQuery.of(i -> i.id(String.valueOf(p.getId())).withObject(p)), IndexCoordinates.of("posts"));
    } catch (Exception ex) {
      log.error("Failed to index post {}: {}", p.getId(), ex.getMessage());
      // Optionally queue for retry
    }
  }

  public void delete(Long id) {
    try {
      es.delete(DeleteQuery.of(d -> d.withId(String.valueOf(id))), IndexCoordinates.of("posts"));
    } catch (Exception ex) {
      log.warn("Failed to delete post {} from index: {}", id, ex.getMessage());
    }
  }

  public List<Post> search(String q, int page, int size) {
    Query query = NativeQuery.builder()
      .withQuery(qs -> qs.match(m -> m.field("content").query(q)))
      .withPageable(org.springframework.data.domain.PageRequest.of(page, size))
      .build();
    SearchHits<Post> hits = es.search(query, Post.class, IndexCoordinates.of("posts"));
    return hits.stream().map(SearchHit::getContent).collect(Collectors.toList());
  }
}

```

PostSearchController.java

```java
package com.example.microblog.web.rest;

import com.example.microblog.domain.Post;
import com.example.microblog.search.PostSearchService;
import java.util.List;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class PostSearchController {

  private final PostSearchService searchService;

  public PostSearchController(PostSearchService searchService) {
    this.searchService = searchService;
  }

  @GetMapping("/_search/posts")
  public List<Post> search(
    @RequestParam String q,
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "20") int size
  ) {
    return searchService.search(q, page, size);
  }
}

```

## Rate-limiting filter using Bucket4j + Redis

```xml
<dependency>
  <groupId>com.github.vladimir-bukhtoyarov</groupId>
  <artifactId>bucket4j-core</artifactId>
  <version>7.7.0</version>
</dependency>
<dependency>
  <groupId>com.github.vladimir-bukhtoyarov</groupId>
  <artifactId>bucket4j-redis-extension</artifactId>
  <version>7.7.0</version>
</dependency>

```

src/main/java/com/example/microblog/security/RateLimitFilter.java

```java
package com.example.microblog.security;

import io.github.bucket4j.*;
import io.github.bucket4j.redis.redisson.RedissonBucket4jExtension;
import jakarta.servlet.*;
import jakarta.servlet.http.*;
import java.io.IOException;
import java.time.Duration;
import org.redisson.api.RedissonClient;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

@Component
public class RateLimitFilter extends OncePerRequestFilter {

  private final RedissonClient redissonClient;
  private final Bucket4jExtension extension;

  public RateLimitFilter(RedissonClient redissonClient) {
    this.redissonClient = redissonClient;
    this.extension = RedissonBucket4jExtension.getInstance();
  }

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
    throws ServletException, IOException {
    String path = request.getRequestURI();
    // example: only rate limit write endpoints
    if (path.startsWith("/api/posts") && "POST".equalsIgnoreCase(request.getMethod())) {
      String key = "rl:user:" + resolveUserOrIp(request);
      // capacity 20 per minute
      Bandwidth limit = Bandwidth.classic(20, Refill.greedy(20, Duration.ofMinutes(1)));
      BucketConfiguration cfg = BucketConfiguration.builder().addLimit(limit).build();
      Bucket bucket = Bucket4j.extension(extension).builder().addLimit(limit).build(redissonClient.getMap("buckets"), key);

      ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);
      response.setHeader("X-RateLimit-Limit", String.valueOf(20));
      response.setHeader("X-RateLimit-Remaining", String.valueOf(probe.getRemainingTokens()));
      if (!probe.isConsumed()) {
        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
        response.getWriter().write("{\"error\":\"rate_limit_exceeded\"}");
        return;
      }
    }
    chain.doFilter(request, response);
  }

  private String resolveUserOrIp(HttpServletRequest req) {
    String user = req.getRemoteUser();
    if (user != null) return user;
    String xff = req.getHeader("X-Forwarded-For");
    if (xff != null) return xff.split(",")[0];
    return req.getRemoteAddr();
  }
}

```

## Testcontainers integration test (end-to-end pipeline)

File: src/test/java/com/example/microblog/integration/FeedIntegrationTest.java

```java
package com.example.microblog.integration;

import com.example.microblog.domain.Post;
import com.example.microblog.repository.PostRepository;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import org.awaitility.Awaitility;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.web.client.RestTemplate;
import org.testcontainers.containers.*;
import org.testcontainers.utility.DockerImageName;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
public class FeedIntegrationTest {

  static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(DockerImageName.parse("postgres:15"))
    .withDatabaseName("microblog")
    .withUsername("microblog")
    .withPassword("microblog");

  static GenericContainer<?> redis = new GenericContainer<>(DockerImageName.parse("redis:7")).withExposedPorts(6379);

  static GenericContainer<?> elastic = new GenericContainer<>(DockerImageName.parse("docker.elastic.co/elasticsearch/elasticsearch:8.8.1"))
    .withEnv("discovery.type", "single-node")
    .withExposedPorts(9200);

  @LocalServerPort
  int port;

  @Autowired
  private PostRepository postRepository;

  private RestTemplate rest = new RestTemplate();

  @BeforeAll
  static void setupAll() {
    postgres.start();
    redis.start();
    elastic.start();
    System.setProperty("spring.datasource.url", postgres.getJdbcUrl());
    System.setProperty("spring.datasource.username", postgres.getUsername());
    System.setProperty("spring.datasource.password", postgres.getPassword());
    System.setProperty("spring.redis.host", redis.getHost());
    System.setProperty("spring.redis.port", String.valueOf(redis.getFirstMappedPort()));
    System.setProperty("spring.elasticsearch.rest.uris", "http://" + elastic.getHost() + ":" + elastic.getFirstMappedPort());
  }

  @AfterAll
  static void teardown() {
    elastic.stop();
    redis.stop();
    postgres.stop();
  }

  @Test
  void createPostPushesToFollowerFeeds() {
    // Create two users via repository or request (simplified: assume user records exist)
    // Create post via repository for author (bypassing auth in tests)
    Post p = new Post();
    p.setAuthor(null); // in real test, create user and set
    p.setContent("integration test post");
    p.setCreatedAt(java.time.Instant.now());
    Post saved = postRepository.save(p);

    // publish event manually or call endpoint (depending on app wiring)
    // Wait until workers push to Redis and timeline read returns it. We'll poll timeline endpoint.
    String timelineUrl = "http://localhost:" + port + "/api/timeline?page=0&size=20";
    Awaitility.await()
      .atMost(Duration.ofSeconds(15))
      .pollInterval(Duration.ofSeconds(1))
      .untilAsserted(() -> {
        List<?> res = rest.getForObject(timelineUrl, List.class);
        Assertions.assertNotNull(res);
      });
  }
}

```

## Cypress e2e test (follow -> post -> timeline -> like)

Place under src/test/javascript/cypress/integration/follow_post_timeline_spec.js

```javascript
describe('Follow -> Post -> Timeline -> Like', () => {
  const api = 'http://localhost:8080/api';
  const userA = { login: 'alice', password: 'password' };
  const userB = { login: 'bob', password: 'password' };

  before(() => {
    // seed accounts via API if your app exposes admin endpoints; else create via migrations
    cy.request('POST', api + '/register', { login: userA.login, email: 'a@example.com', password: userA.password });
    cy.request('POST', api + '/register', { login: userB.login, email: 'b@example.com', password: userB.password });
  });

  it('bob posts and alice sees it after following and can like', () => {
    // bob login
    cy.request('POST', api + '/authenticate', userB).then(resp => {
      const bobToken = resp.body.id_token;
      // bob creates post
      cy.request({
        method: 'POST',
        url: api + '/posts',
        headers: { Authorization: 'Bearer ' + bobToken },
        body: { content: 'Hello from Bob!' },
      }).then(postResp => {
        expect(postResp.status).to.eq(201);
      });

      // alice login
      cy.request('POST', api + '/authenticate', userA).then(r2 => {
        const aliceToken = r2.body.id_token;
        // alice follows bob (need bob's id -> fetch user by login)
        cy.request({ method: 'GET', url: api + '/users/' + userB.login }).then(u => {
          const bobId = u.body.id;
          cy.request({
            method: 'POST',
            url: api + '/users/' + bobId + '/follow',
            headers: { Authorization: 'Bearer ' + aliceToken },
          }).then(fres => {
            expect(fres.status).to.be.oneOf([200]);
            // wait a moment for fan-out
            cy.wait(2000);
            // call timeline
            cy.request({ method: 'GET', url: api + '/timeline?page=0&size=20', headers: { Authorization: 'Bearer ' + aliceToken } }).then(
              tl => {
                expect(tl.status).to.eq(200);
                const posts = tl.body.content || tl.body;
                expect(posts.some(p => p.content && p.content.includes('Hello from Bob!'))).to.be.true;
                const postId = posts.find(p => p.content.includes('Hello from Bob!')).id;
                // alice likes the post
                cy.request({
                  method: 'POST',
                  url: api + '/posts/' + postId + '/like',
                  headers: { Authorization: 'Bearer ' + aliceToken },
                }).then(likeResp => {
                  expect(likeResp.status).to.eq(200);
                  expect(likeResp.body.likeCount).to.be.greaterThan(0);
                });
              },
            );
          });
        });
      });
    });
  });
});
```

## React timeline & composer components (JSX)

Assume JHipster React client layout. Place under src/main/webapp/app/modules/microblog/
PostComposer.jsx

```jsx
import React, { useState } from 'react';
import axios from 'axios';

export default function PostComposer({ onPosted }) {
  const [content, setContent] = useState('');
  const [saving, setSaving] = useState(false);

  const submit = async () => {
    if (!content.trim()) return;
    setSaving(true);
    try {
      const token = localStorage.getItem('authenticationToken');
      const resp = await axios.post('/api/posts', { content }, { headers: { Authorization: 'Bearer ' + token } });
      setContent('');
      onPosted && onPosted(resp.data);
    } catch (e) {
      console.error(e);
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="post-composer card p-3 mb-3">
      <textarea
        value={content}
        onChange={e => setContent(e.target.value)}
        rows={4}
        className="form-control"
        placeholder="What's happening?"
      />
      <div className="d-flex justify-content-end mt-2">
        <button className="btn btn-primary" disabled={saving} onClick={submit}>
          {saving ? 'Posting...' : 'Post'}
        </button>
      </div>
    </div>
  );
}
```

PostItem.jsx

```jsx
import React, { useState } from 'react';
import axios from 'axios';

export default function PostItem({ post, onLikeChanged }) {
  const [likeCount, setLikeCount] = useState(post.likeCount || 0);
  const [liked, setLiked] = useState(false);
  const token = localStorage.getItem('authenticationToken');

  async function toggleLike() {
    // optimistic UI
    setLiked(!liked);
    setLikeCount(liked ? likeCount - 1 : likeCount + 1);
    try {
      if (!liked) {
        const res = await axios.post(`/api/posts/${post.id}/like`, {}, { headers: { Authorization: 'Bearer ' + token } });
        setLikeCount(res.data.likeCount);
        setLiked(true);
      } else {
        const res = await axios.delete(`/api/posts/${post.id}/like`, { headers: { Authorization: 'Bearer ' + token } });
        setLikeCount(res.data.likeCount);
        setLiked(false);
      }
      onLikeChanged && onLikeChanged(post.id, likeCount);
    } catch (e) {
      // rollback optimistic update on error
      setLiked(!liked);
      setLikeCount(likeCount);
      console.error(e);
    }
  }

  return (
    <div className="post-item card mb-2 p-2">
      <div className="d-flex justify-content-between">
        <div>
          <strong>{post.authorLogin}</strong> • <small>{new Date(post.createdAt).toLocaleString()}</small>
        </div>
      </div>
      <div className="mt-2">{post.content}</div>
      <div className="mt-2 d-flex align-items-center">
        <button className={`btn btn-sm ${liked ? 'btn-primary' : 'btn-outline-primary'}`} onClick={toggleLike}>
          {liked ? 'Liked' : 'Like'} ({likeCount})
        </button>
      </div>
    </div>
  );
}
```

TimelinePage.jsx

```jsx
import React, { useEffect, useState } from 'react';
import axios from 'axios';
import PostComposer from './PostComposer';
import PostItem from './PostItem';

export default function TimelinePage() {
  const [posts, setPosts] = useState([]);
  const [page, setPage] = useState(0);
  const size = 20;

  async function loadPage(p = 0) {
    const token = localStorage.getItem('authenticationToken');
    const resp = await axios.get(`/api/timeline?page=${p}&size=${size}`, { headers: { Authorization: 'Bearer ' + token } });
    const content = resp.data.content || resp.data; // adapt to backend
    setPosts(p === 0 ? content : [...posts, ...content]);
    setPage(p);
  }
  useEffect(() => {
    loadPage(0);
  }, []);

  return (
    <div>
      <PostComposer
        onPosted={p => {
          // prepend
          setPosts([p, ...posts]);
        }}
      />
      <div>
        {posts.map(post => (
          <PostItem key={post.id} post={post} />
        ))}
        <div className="text-center mt-3">
          <button className="btn btn-secondary" onClick={() => loadPage(page + 1)}>
            Load more
          </button>
        </div>
      </div>
    </div>
  );
}
```

## GitHub Actions CI YAML

```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: microblog
          POSTGRES_USER: microblog
          POSTGRES_PASSWORD: microblog
        ports: ['5432:5432']
      redis:
        image: redis:7
        ports: ['6379:6379']
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      - name: Cache Maven local repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
      - name: Build and run unit tests
        env:
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/microblog
          SPRING_DATASOURCE_USERNAME: microblog
          SPRING_DATASOURCE_PASSWORD: microblog
          SPRING_REDIS_HOST: localhost
          SPRING_REDIS_PORT: 6379
        run: mvn -B -DskipTests=false test -e
      - name: Build package
        run: mvn -B -DskipTests package
      - name: Build Docker image
        run: docker build -t ${{ github.repository }}:${{ github.sha }} .
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/*.jar
```

## Dockerfile + improved docker-compose.yml

```yaml
FROM eclipse-temurin:17-jdk-jammy as build
WORKDIR /workspace
COPY mvnw pom.xml ./
COPY .mvn .mvn
RUN chmod +x mvnw
RUN ./mvnw -B -DskipTests package -DskipITs

FROM eclipse-temurin:17-jre-jammy
ARG JAR_FILE=target/*.jar
COPY --from=build /workspace/${JAR_FILE} app.jar
EXPOSE 8080
ENV JAVA_OPTS="-Xms256m -Xmx512m"
ENTRYPOINT exec java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar
```

improved docker-compose.yml (project root)

```yaml
version: '3.8'
services:
  app:
    build: .
    image: microblog_app:latest
    restart: unless-stopped
    ports:
      - '8080:8080'
    environment:
      SPRING_PROFILES_ACTIVE: dev
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/microblog
      SPRING_DATASOURCE_USERNAME: microblog
      SPRING_DATASOURCE_PASSWORD: microblog
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
      SPRING_ELASTICSEARCH_REST_URIS: http://elasticsearch:9200
    depends_on:
      - postgres
      - redis
      - elasticsearch

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: microblog
      POSTGRES_USER: microblog
      POSTGRES_PASSWORD: microblog
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U microblog']
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7
    command: ['redis-server', '--save', '60', '1']
    ports:
      - '6379:6379'
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 10s
      timeout: 5s
      retries: 3

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.8.1
    environment:
      - discovery.type=single-node
      - 'ES_JAVA_OPTS=-Xms512m -Xmx512m'
    ulimits:
      memlock:
        soft: -1
        hard: -1
    ports:
      - '9200:9200'
    healthcheck:
      test: ['CMD-SHELL', "curl -s http://localhost:9200/_cluster/health | grep -q '\"status\":\"green\"\\|\"status\":\"yellow\"'"]
      interval: 10s
      retries: 10

volumes:
  pgdata:
```

## Runbook + Prometheus alert rules

runbook.md (docs/runbook.md)

```markdown
# Runbook — Microblog Service (short)

## Services

- App: `microblog` Java Spring Boot
- Postgres: postgres:15
- Redis: redis:7
- Elasticsearch: 8.x

## Common incidents

### 1) Redis OOM / high memory

- Symptom: feed latency high; app logs show Redis OOM or connection errors; metrics: redis_memory_used.
- Action:
  1. Check memory usage: `redis-cli INFO memory`
  2. Check eviction policy: `redis-cli CONFIG GET maxmemory-policy`
  3. If OOM: increase instance or scale Redis cluster; set eviction policy `volatile-lru`.
  4. Restart workers if necessary.
  5. If necessary, disable push worker via FEATURE_FLAG to avoid more writes.

### 2) Elasticsearch red / yellow

- Symptom: search failures; ES health red.
- Action:
  1. Inspect cluster health: `curl localhost:9200/_cluster/health?pretty`
  2. If yellow: check unassigned shards: `curl localhost:9200/_cat/shards`
  3. If red: restore from snapshot or reindex from DB (run reindex job).

### 3) DB migration failure on deploy

- Symptom: Liquibase error on startup.
- Action:
  1. Do not restart others; revert to previous image if necessary.
  2. Inspect Liquibase logs: `tail -n 200 app.log`
  3. If data migration problem, create a manual rollback or restore from backup.

### 4) Fan-out backlog / worker crash

- Symptom: timeline not updated for followers; worker logs errors.
- Action:
  1. Inspect worker logs, restart worker service.
  2. Check backlog in DLQ (if implemented).
  3. If huge backlog, scale workers horizontally.

## Run commands (k8s / docker-compose)

- docker-compose logs -f app
- docker-compose exec postgres psql -U microblog microblog
- docker-compose exec redis redis-cli

## Contacts

- On-call: team lead
```

Prometheus alert rules (prometheus/rules/microblog.rules.yml)

```yaml
groups:
  - name: microblog.rules
    rules:
      - alert: HighTimelineLatency
        expr: histogram_quantile(0.8, sum(rate(http_server_requests_seconds_bucket{uri=~"/api/timeline.*"}[5m])) by (le)) > 0.2
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: 'High timeline latency (P80 > 200ms)'
          description: 'Investigate Redis/DB/worker performance.'

      - alert: RedisHighMemory
        expr: redis_memory_used_bytes > 0.8 * redis_memory_total_bytes
        for: 2m
        labels: { severity: critical }
        annotations:
          summary: 'Redis memory pressure'
          description: 'Redis used memory > 80%.'

      - alert: ESClusterYellow
        expr: elasticsearch_cluster_health_status{job="elasticsearch"} == 1
        for: 1m
        labels: { severity: warning }
        annotations:
          summary: 'Elasticsearch cluster yellow'
          description: 'One or more shards unassigned.'

      - alert: PostgresDown
        expr: pg_up == 0
        for: 5m
        labels: { severity: critical }
        annotations:
          summary: 'Postgres is down'
          description: 'Database unreachable for more than 5m.'

      - alert: ExcessiveRateLimitHits
        expr: increase(custom_rate_limit_hits_total[5m]) > 100
        labels: { severity: warning }
        annotations:
          summary: 'High rate limit events'
          description: 'Many clients are hitting rate limits.'
```

## Repository methods

Put these files under src/main/java/com/example/microblog/repository/

PostRepository.java

```java
package com.example.microblog.repository;

import com.example.microblog.domain.Post;
import java.util.Collection;
import java.util.List;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

public interface PostRepository extends JpaRepository<Post, Long> {
  // Find posts by a list of authors (works as fan-out read)
  Page<Post> findByAuthorIdIn(List<Long> authorIds, Pageable pageable);

  // Fetch posts by ids (used to fill details for ids from Redis)
  List<Post> findByIdIn(Collection<Long> ids);

  // Atomic counter increments/decrements (call inside @Transactional service methods)
  @Modifying
  @Query("UPDATE Post p SET p.likeCount = p.likeCount + 1 WHERE p.id = :postId")
  int incrementLikeCountById(@Param("postId") Long postId);

  @Modifying
  @Query("UPDATE Post p SET p.likeCount = CASE WHEN p.likeCount > 0 THEN p.likeCount - 1 ELSE 0 END WHERE p.id = :postId")
  int decrementLikeCountById(@Param("postId") Long postId);

  @Modifying
  @Query("UPDATE Post p SET p.commentCount = p.commentCount + 1 WHERE p.id = :postId")
  int incrementCommentCountById(@Param("postId") Long postId);
}

```

Notes:

The @Modifying update methods return an int indicating rows affected. They must be executed within a @Transactional context (your service/controller methods should be @Transactional or call them inside one).

I used findByAuthorIdIn naming so Spring Data JPA auto-generates it (instead of a custom @Query).

FollowRepository.java

```java
package com.example.microblog.repository;

import com.example.microblog.domain.Follow;
import java.util.List;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;

public interface FollowRepository extends JpaRepository<Follow, Long> {
  // Return list of followee IDs a user follows (fan-out-read)
  @Query("SELECT f.followee.id FROM Follow f WHERE f.follower.id = :followerId")
  List<Long> findFolloweeIdsByFollowerId(@Param("followerId") Long followerId);

  // Return followers of a followee: used for push worker
  @Query("SELECT f.follower.id FROM Follow f WHERE f.followee.id = :followeeId")
  List<Long> findFollowerIdsByFolloweeId(@Param("followeeId") Long followeeId);

  // Paged follower fetch using Pageable — preferred for very large follower lists
  @Query("SELECT f.follower.id FROM Follow f WHERE f.followee.id = :followeeId")
  List<Long> findFollowerIdsByFolloweeId(@Param("followeeId") Long followeeId, Pageable pageable);

  boolean existsByFollowerIdAndFolloweeId(Long followerId, Long followeeId);

  void deleteByFollowerIdAndFolloweeId(Long followerId, Long followeeId);
}

```

Notes:

findFollowerIdsByFolloweeId(..., Pageable) lets the push worker request pages of follower IDs by passing a PageRequest.of(offsetPage, pageSize) instead of offset+limit arithmetic. If you prefer offset-based method, we can add a native query with LIMIT/OFFSET.

PostLikeRepository.java

```java
package com.example.microblog.repository;

import com.example.microblog.domain.PostLike;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PostLikeRepository extends JpaRepository<PostLike, Long> {
  boolean existsByPostIdAndUserId(Long postId, Long userId);

  void deleteByPostIdAndUserId(Long postId, Long userId);
}

```

## Full integration test (end-to-end)

Place under src/test/java/com/example/microblog/integration/FullIntegrationTest.java

```java
package com.example.microblog.integration;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.time.Duration;
import java.util.*;
import org.awaitility.Awaitility;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.http.*;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.web.client.RestTemplate;
import org.testcontainers.containers.*;
import org.testcontainers.utility.DockerImageName;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class FullIntegrationTest {

  static final DockerImageName POSTGRES_IMAGE = DockerImageName.parse("postgres:15");
  static final DockerImageName REDIS_IMAGE = DockerImageName.parse("redis:7");
  static final DockerImageName ELASTIC_IMAGE = DockerImageName.parse("docker.elastic.co/elasticsearch/elasticsearch:8.8.1");

  private PostgreSQLContainer<?> postgres;
  private GenericContainer<?> redis;
  private GenericContainer<?> elastic;

  @LocalServerPort
  private int port;

  private RestTemplate rest = new RestTemplate();
  private ObjectMapper mapper = new ObjectMapper();

  @BeforeAll
  void startContainers() {
    postgres = new PostgreSQLContainer<>(POSTGRES_IMAGE).withDatabaseName("microblog").withUsername("microblog").withPassword("microblog");
    postgres.start();

    redis = new GenericContainer<>(REDIS_IMAGE).withExposedPorts(6379);
    redis.start();

    elastic = new GenericContainer<>(ELASTIC_IMAGE)
      .withEnv("discovery.type", "single-node")
      .withEnv("ES_JAVA_OPTS", "-Xms256m -Xmx256m")
      .withExposedPorts(9200);
    elastic.start();

    // Set Spring properties so the application uses containers
    System.setProperty("spring.datasource.url", postgres.getJdbcUrl());
    System.setProperty("spring.datasource.username", postgres.getUsername());
    System.setProperty("spring.datasource.password", postgres.getPassword());
    System.setProperty("spring.redis.host", redis.getHost());
    System.setProperty("spring.redis.port", String.valueOf(redis.getFirstMappedPort()));
    System.setProperty("spring.elasticsearch.rest.uris", "http://" + elastic.getHost() + ":" + elastic.getFirstMappedPort());
  }

  @AfterAll
  void stopContainers() {
    if (elastic != null) elastic.stop();
    if (redis != null) redis.stop();
    if (postgres != null) postgres.stop();
  }

  // Helper: register a user via /api/register (JHipster)
  private void registerUser(String login, String email, String password) {
    String url = "http://localhost:" + port + "/api/register";
    Map<String, Object> body = new HashMap<>();
    body.put("login", login);
    body.put("email", email);
    body.put("password", password);
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    HttpEntity<Map<String, Object>> req = new HttpEntity<>(body, headers);
    ResponseEntity<String> resp = rest.postForEntity(url, req, String.class);
    Assertions.assertTrue(resp.getStatusCode().is2xxSuccessful(), "Registration should succeed");
  }

  // Helper: authenticate via /api/authenticate -> returns token
  private String authenticate(String username, String password) throws Exception {
    String url = "http://localhost:" + port + "/api/authenticate";
    Map<String, String> body = Map.of("username", username, "password", password);
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    ResponseEntity<String> resp = rest.postForEntity(url, new HttpEntity<>(body, headers), String.class);
    Assertions.assertEquals(HttpStatus.OK, resp.getStatusCode());
    JsonNode node = mapper.readTree(resp.getBody());
    String token = node.path("id_token").asText();
    Assertions.assertFalse(token.isBlank(), "Token must not be blank");
    return token;
  }

  // Helper: get user by login -> GET /api/users/{login}
  private JsonNode getUserByLogin(String login) throws Exception {
    String url = "http://localhost:" + port + "/api/users/" + login;
    ResponseEntity<String> resp = rest.getForEntity(url, String.class);
    Assertions.assertEquals(HttpStatus.OK, resp.getStatusCode());
    return mapper.readTree(resp.getBody());
  }

  @Test
  void followPostTimelineFlow() throws Exception {
    String alice = "alice_tc";
    String bob = "bob_tc";
    String password = "Passw0rd!";
    // Register users
    registerUser(alice, alice + "@example.com", password);
    registerUser(bob, bob + "@example.com", password);

    // Authenticate
    String aliceToken = authenticate(alice, password);
    String bobToken = authenticate(bob, password);

    // Get bob id
    JsonNode bobJson = getUserByLogin(bob);
    long bobId = bobJson.path("id").asLong();

    // Alice follows Bob (POST /api/users/{id}/follow)
    String followUrl = "http://localhost:" + port + "/api/users/" + bobId + "/follow";
    HttpHeaders headersAlice = new HttpHeaders();
    headersAlice.setBearerAuth(aliceToken);
    headersAlice.setContentType(MediaType.APPLICATION_JSON);
    ResponseEntity<String> followResp = rest.postForEntity(followUrl, new HttpEntity<>(null, headersAlice), String.class);
    Assertions.assertTrue(followResp.getStatusCode().is2xxSuccessful());

    // Bob creates a post
    String postUrl = "http://localhost:" + port + "/api/posts";
    HttpHeaders headersBob = new HttpHeaders();
    headersBob.setBearerAuth(bobToken);
    headersBob.setContentType(MediaType.APPLICATION_JSON);
    Map<String, Object> postBody = Map.of(
      "content",
      "Hello from Bob (integration test) " + UUID.randomUUID().toString(),
      "visibility",
      "PUBLIC"
    );
    ResponseEntity<String> postResp = rest.postForEntity(postUrl, new HttpEntity<>(postBody, headersBob), String.class);
    Assertions.assertEquals(HttpStatus.CREATED, postResp.getStatusCode());
    JsonNode createdPost = mapper.readTree(postResp.getBody());
    long createdPostId = createdPost.path("id").asLong();
    String createdContent = createdPost.path("content").asText();

    // Now poll Alice timeline until it contains Bob's post (await for up to 20s)
    String timelineUrl = "http://localhost:" + port + "/api/timeline?page=0&size=20";
    Awaitility.await()
      .atMost(Duration.ofSeconds(20))
      .pollInterval(Duration.ofSeconds(1))
      .untilAsserted(() -> {
        HttpHeaders h = new HttpHeaders();
        h.setBearerAuth(aliceToken);
        ResponseEntity<String> tlResp = rest.exchange(timelineUrl, HttpMethod.GET, new HttpEntity<>(h), String.class);
        Assertions.assertEquals(HttpStatus.OK, tlResp.getStatusCode());
        JsonNode body = mapper.readTree(tlResp.getBody());
        // JHipster pageable returns { content: [ ... ], totalElements: ..., ...}
        JsonNode contentNode = body.has("content") ? body.get("content") : body;
        boolean found = false;
        if (contentNode.isArray()) {
          for (JsonNode n : contentNode) {
            if (n.path("id").asLong() == createdPostId || n.path("content").asText().contains("Hello from Bob")) {
              found = true;
              break;
            }
          }
        }
        Assertions.assertTrue(found, "Alice timeline should contain Bob's post");
      });

    // Finally, have Alice like the post, and assert likeCount increments
    String likeUrl = "http://localhost:" + port + "/api/posts/" + createdPostId + "/like";
    ResponseEntity<String> likeResp = rest.postForEntity(likeUrl, new HttpEntity<>(null, headersAlice), String.class);
    Assertions.assertEquals(HttpStatus.OK, likeResp.getStatusCode());
    JsonNode likeBody = mapper.readTree(likeResp.getBody());
    int likeCount = likeBody.path("likeCount").asInt();
    Assertions.assertTrue(likeCount >= 1, "Like count should be >= 1 after liking");
  }
}

```

```xml
<dependency>
  <groupId>org.testcontainers</groupId>
  <artifactId>testcontainers</artifactId>
  <version>1.18.3</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.testcontainers</groupId>
  <artifactId>junit-jupiter</artifactId>
  <version>1.18.3</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.awaitility</groupId>
  <artifactId>awaitility</artifactId>
  <version>4.2.0</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <scope>test</scope>
</dependency>

```
